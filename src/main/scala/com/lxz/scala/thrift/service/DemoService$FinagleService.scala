/**
 * Generated by Scrooge
 *   version: 4.19.0
 *   rev: 7d34fd72196cf3468c490a76681e002cc11d94fa
 *   built at: 20170816-172213
 */
package com.lxz.scala.thrift.service

import java.util.Arrays

import com.twitter.finagle.stats.{Counter, NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.{SimpleFilter, Thrift, Filter => finagle$Filter, Service => finagle$Service}
import com.twitter.scrooge.{TReusableBuffer, ThriftMethod, ThriftStruct}
import com.twitter.util.{Future, Return, Throw, Throwables}
import org.apache.thrift.TApplicationException
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TMemoryInputTransport

import scala.collection.mutable.{ArrayBuffer => mutable$ArrayBuffer, HashMap => mutable$HashMap}
import scala.language.higherKinds


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
class DemoService$FinagleService(
  iface: DemoService[Future],
  protocolFactory: TProtocolFactory,
  stats: StatsReceiver,
  maxThriftBufferSize: Int,
  serviceName: String
) extends com.twitter.finagle.Service[Array[Byte], Array[Byte]] {
  import DemoService._

  def this(
    iface: DemoService[Future],
    protocolFactory: TProtocolFactory,
    stats: StatsReceiver,
    maxThriftBufferSize: Int
  ) = this(iface, protocolFactory, stats, maxThriftBufferSize, "DemoService")

  def this(
    iface: DemoService[Future],
    protocolFactory: TProtocolFactory
  ) = this(iface, protocolFactory, NullStatsReceiver, Thrift.maxThriftBufferSize)

  private[this] val tlReusableBuffer = TReusableBuffer()

  protected val serviceMap = new mutable$HashMap[String, finagle$Service[(TProtocol, Int), Array[Byte]]]()

  protected def addService(name: String, service: finagle$Service[(TProtocol, Int), Array[Byte]]): Unit = {
    serviceMap(name) = service
  }

  protected def exception(name: String, seqid: Int, code: Int, message: String): Future[Array[Byte]] = {
    try {
      val x = new TApplicationException(code, message)
      val memoryBuffer = tlReusableBuffer.get()
      try {
        val oprot = protocolFactory.getProtocol(memoryBuffer)

        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()
        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } finally {
        tlReusableBuffer.reset()
      }
    } catch {
      case e: Exception => Future.exception(e)
    }
  }

  protected def reply(name: String, seqid: Int, result: ThriftStruct): Future[Array[Byte]] = {
    try {
      val memoryBuffer = tlReusableBuffer.get()
      try {
        val oprot = protocolFactory.getProtocol(memoryBuffer)

        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()

        Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()))
      } finally {
        tlReusableBuffer.reset()
      }
    } catch {
      case e: Exception => Future.exception(e)
    }
  }

  final def apply(request: Array[Byte]): Future[Array[Byte]] = {
    val inputTransport = new TMemoryInputTransport(request)
    val iprot = protocolFactory.getProtocol(inputTransport)

    try {
      val msg = iprot.readMessageBegin()
      val service = serviceMap.get(msg.name)
      service match {
        case _root_.scala.Some(svc) =>
          svc(iprot, msg.seqid)
        case _ =>
          TProtocolUtil.skip(iprot, TType.STRUCT)
          exception(msg.name, msg.seqid, TApplicationException.UNKNOWN_METHOD,
            "Invalid method name: '" + msg.name + "'")
      }
    } catch {
      case e: Exception => Future.exception(e)
    }
  }

  private object ThriftMethodStats {
    def apply(stats: StatsReceiver): ThriftMethodStats =
      ThriftMethodStats(
        stats.counter("requests"),
        stats.counter("success"),
        stats.counter("failures"),
        stats.scope("failures")
      )
  }

  private case class ThriftMethodStats(
    requestsCounter: Counter,
    successCounter: Counter,
    failuresCounter: Counter,
    failuresScope: StatsReceiver
  )

  protected def perMethodStatsFilter(
    method: ThriftMethod,
    stats: StatsReceiver
  ): SimpleFilter[method.Args, method.SuccessType] = {
    val methodStats = ThriftMethodStats((if (serviceName != "") stats.scope(serviceName) else stats).scope(method.name))
    new SimpleFilter[method.Args, method.SuccessType] {
      def apply(
        args: method.Args,
        service: finagle$Service[method.Args, method.SuccessType]
      ): Future[method.SuccessType] = {
        methodStats.requestsCounter.incr()
        service(args).respond {
          case Return(_) =>
            methodStats.successCounter.incr()
          case Throw(ex) =>
            methodStats.failuresCounter.incr()
            methodStats.failuresScope.counter(Throwables.mkString(ex): _*).incr()
        }
      }
    }
  }
  // ---- end boilerplate.

  addService("method1", {
    val statsFilter = perMethodStatsFilter(Method1, stats)
  
    val methodService = new finagle$Service[Method1.Args, Method1.SuccessType] {
      def apply(args: Method1.Args): Future[Method1.SuccessType] = {
        iface.method1()
      }
    }
  
    val protocolExnFilter = new SimpleFilter[(TProtocol, Int), Array[Byte]] {
      def apply(
        request: (TProtocol, Int),
        service: finagle$Service[(TProtocol, Int), Array[Byte]]
      ): Future[Array[Byte]] = {
        val (iprot, seqid) = request
        service(request).rescue {
          case e: TProtocolException => {
            iprot.readMessageEnd()
            exception("method1", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
          }
          case e: Exception => Future.exception(e)
        }
      }
    }
  
    val serdeFilter = new finagle$Filter[(TProtocol, Int), Array[Byte], Method1.Args, Method1.SuccessType] {
      override def apply(
        request: (TProtocol, Int),
        service: finagle$Service[Method1.Args, Method1.SuccessType]
      ): Future[Array[Byte]] = {
        val (iprot, seqid) = request
        val args = Method1.Args.decode(iprot)
        iprot.readMessageEnd()
        val res = service(args)
        res.flatMap { value =>
          reply("method1", seqid, Method1.Result(success = Some(value)))
        }.rescue {
          case e => Future.exception(e)
        }
      }
    }
  
    protocolExnFilter.andThen(serdeFilter).andThen(statsFilter).andThen(methodService)
  })
  addService("method2", {
    val statsFilter = perMethodStatsFilter(Method2, stats)
  
    val methodService = new finagle$Service[Method2.Args, Method2.SuccessType] {
      def apply(args: Method2.Args): Future[Method2.SuccessType] = {
        iface.method2(args.a, args.b)
      }
    }
  
    val protocolExnFilter = new SimpleFilter[(TProtocol, Int), Array[Byte]] {
      def apply(
        request: (TProtocol, Int),
        service: finagle$Service[(TProtocol, Int), Array[Byte]]
      ): Future[Array[Byte]] = {
        val (iprot, seqid) = request
        service(request).rescue {
          case e: TProtocolException => {
            iprot.readMessageEnd()
            exception("method2", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
          }
          case e: Exception => Future.exception(e)
        }
      }
    }
  
    val serdeFilter = new finagle$Filter[(TProtocol, Int), Array[Byte], Method2.Args, Method2.SuccessType] {
      override def apply(
        request: (TProtocol, Int),
        service: finagle$Service[Method2.Args, Method2.SuccessType]
      ): Future[Array[Byte]] = {
        val (iprot, seqid) = request
        val args = Method2.Args.decode(iprot)
        iprot.readMessageEnd()
        val res = service(args)
        res.flatMap { value =>
          reply("method2", seqid, Method2.Result(success = Some(value)))
        }.rescue {
          case e => Future.exception(e)
        }
      }
    }
  
    protocolExnFilter.andThen(serdeFilter).andThen(statsFilter).andThen(methodService)
  })
  addService("method3", {
    val statsFilter = perMethodStatsFilter(Method3, stats)
  
    val methodService = new finagle$Service[Method3.Args, Method3.SuccessType] {
      def apply(args: Method3.Args): Future[Method3.SuccessType] = {
        iface.method3()
      }
    }
  
    val protocolExnFilter = new SimpleFilter[(TProtocol, Int), Array[Byte]] {
      def apply(
        request: (TProtocol, Int),
        service: finagle$Service[(TProtocol, Int), Array[Byte]]
      ): Future[Array[Byte]] = {
        val (iprot, seqid) = request
        service(request).rescue {
          case e: TProtocolException => {
            iprot.readMessageEnd()
            exception("method3", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
          }
          case e: Exception => Future.exception(e)
        }
      }
    }
  
    val serdeFilter = new finagle$Filter[(TProtocol, Int), Array[Byte], Method3.Args, Method3.SuccessType] {
      override def apply(
        request: (TProtocol, Int),
        service: finagle$Service[Method3.Args, Method3.SuccessType]
      ): Future[Array[Byte]] = {
        val (iprot, seqid) = request
        val args = Method3.Args.decode(iprot)
        iprot.readMessageEnd()
        val res = service(args)
        res.flatMap { value =>
          reply("method3", seqid, Method3.Result())
        }.rescue {
          case e => Future.exception(e)
        }
      }
    }
  
    protocolExnFilter.andThen(serdeFilter).andThen(statsFilter).andThen(methodService)
  })
  addService("genId", {
    val statsFilter = perMethodStatsFilter(GenId, stats)
  
    val methodService = new finagle$Service[GenId.Args, GenId.SuccessType] {
      def apply(args: GenId.Args): Future[GenId.SuccessType] = {
        iface.genId()
      }
    }
  
    val protocolExnFilter = new SimpleFilter[(TProtocol, Int), Array[Byte]] {
      def apply(
        request: (TProtocol, Int),
        service: finagle$Service[(TProtocol, Int), Array[Byte]]
      ): Future[Array[Byte]] = {
        val (iprot, seqid) = request
        service(request).rescue {
          case e: TProtocolException => {
            iprot.readMessageEnd()
            exception("genId", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage)
          }
          case e: Exception => Future.exception(e)
        }
      }
    }
  
    val serdeFilter = new finagle$Filter[(TProtocol, Int), Array[Byte], GenId.Args, GenId.SuccessType] {
      override def apply(
        request: (TProtocol, Int),
        service: finagle$Service[GenId.Args, GenId.SuccessType]
      ): Future[Array[Byte]] = {
        val (iprot, seqid) = request
        val args = GenId.Args.decode(iprot)
        iprot.readMessageEnd()
        val res = service(args)
        res.flatMap { value =>
          reply("genId", seqid, GenId.Result(success = Some(value)))
        }.rescue {
          case e => Future.exception(e)
        }
      }
    }
  
    protocolExnFilter.andThen(serdeFilter).andThen(statsFilter).andThen(methodService)
  })
}
